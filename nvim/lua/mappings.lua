local m = vim.keymap.set

m("n", ";", ":", { desc = "Command mode" })
m("i", "jk", "<Esc>", { desc = "Escape" })
m("n", "<leader>w", "<cmd>w<cr>", { desc = "Save" })
m("n", "<leader>q", "<cmd>q<cr>", { desc = "Quit" })
m("n", "<leader>e", "<cmd>NvimTreeToggle<cr>", { desc = "File tree" })
m("n", "<Tab>", "<cmd>bnext<cr>", { silent = true, desc = "Next buffer" })
m("n", "<S-Tab>", "<cmd>bprevious<cr>", { silent = true, desc = "Previous buffer" })
m("n", "<leader>bn", "<cmd>bnext<cr>", { desc = "Next buffer" })
m("n", "<leader>bp", "<cmd>bprevious<cr>", { desc = "Previous buffer" })
m("n", "<leader>bd", "<cmd>bdelete<cr>", { desc = "Close buffer" })
m("n", "<leader><leader>", function()
  require("telescope.builtin").find_files({ cwd = vim.fn.expand("~") })
end, { desc = "Find files (home)" })
m("n", "<leader>ff", "<cmd>Telescope find_files<cr>", { desc = "Find files" })
m("n", "<leader>fg", "<cmd>Telescope live_grep<cr>", { desc = "Live grep" })
m("n", "<leader>fb", "<cmd>Telescope buffers<cr>", { desc = "Buffers" })
m("n", "<leader>fh", "<cmd>Telescope help_tags<cr>", { desc = "Help tags" })
m("n", "<leader>fr", "<cmd>Telescope resume<cr>", { desc = "Resume" })
-- Code (LSP) â€“ peek in float (no jump); buffer maps in lspconfig override in LSP buffers
local peek = require("peek")
local function code_action(fn)
  return function()
    if vim.fn.mode():match("[vV\22]") then vim.cmd.normal("\\<Esc>") end
    fn()
  end
end
m("n", "<leader>cd", peek.peek_definition, { desc = "Peek definitions" })
m("n", "<leader>cr", peek.peek_references, { desc = "Peek references" })
m("n", "<leader>ci", peek.peek_implementations, { desc = "Peek implementations" })
m("n", "<leader>cD", vim.lsp.buf.definition, { desc = "Go to definition" })
m("n", "<leader>cR", vim.lsp.buf.references, { desc = "Go to references" })
m("n", "<leader>cI", vim.lsp.buf.implementation, { desc = "Go to implementation" })
m("n", "<leader>cT", vim.lsp.buf.type_definition, { desc = "Go to type definition" })
m("n", "<leader>ca", vim.lsp.buf.code_action, { desc = "Code action" })
m("n", "<leader>cf", function() require("conform").format({ async = true, lsp_fallback = true }) end, { desc = "Format" })
m("v", "<leader>cd", code_action(peek.peek_definition), { desc = "Peek definitions" })
m("v", "<leader>cr", code_action(peek.peek_references), { desc = "Peek references" })
m("v", "<leader>ci", code_action(peek.peek_implementations), { desc = "Peek implementations" })
m("v", "<leader>ca", code_action(vim.lsp.buf.code_action), { desc = "Code action" })
m("v", "<leader>cf", code_action(function() require("conform").format({ async = true, lsp_fallback = true }) end), { desc = "Format" })
m("v", "<leader>cD", code_action(vim.lsp.buf.definition), { desc = "Go to definition" })
m("v", "<leader>cR", code_action(vim.lsp.buf.references), { desc = "Go to references" })
m("v", "<leader>cI", code_action(vim.lsp.buf.implementation), { desc = "Go to implementation" })
m("v", "<leader>cT", code_action(vim.lsp.buf.type_definition), { desc = "Go to type definition" })